# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>
from __python__ import hash_literals, bound_methods

from encodings import base64encode

bridge = None
AUTH_TOKEN = '__AUTH_TOKEN__'

def qt_bridge():
    return bridge

def callback(name, data, console_err):
    bridge = qt_bridge()
    if not bridge:
        console.error(console_err or ('Aborting callback: ' + name + ' as Qt bridge not available'))
    else:
        bridge.callback(name, JSON.stringify(data))

def connect_signal(name, func):
    bridge = qt_bridge()
    if not bridge:
        console.error('Failed to connect signal: ' + name + ' as Qt bridge not available')
    else:
        signal = bridge[name]
        if not signal:
            console.error('Failed to connect signal: ' + name + ' as no signal by that name exists')
        else:
            signal.connect(func)

class Bridge:

    def __init__(self, proceed):
        self.proceed = proceed
        r = Uint8Array(16)
        window.crypto.getRandomValues(r)
        self.bridge_id = window.performance.now() + ' ' + base64encode(r)
        self.initial_connection = True
        window.get_bridge_id = def():
            return self.bridge_id
        self.reconnect()

    def reconnect(self):
        self.socket = v"new WebSocket('ws://127.0.0.1:__WEBSOCKET_PORT__')"
        self.socket.onmessage = self.onmessage
        self.socket.onclose = self.onclose
        self.socket.onopen = self.onopen
        self.socket.onerror = self.onerror

    def send_message(self, msg_type, **data):
        self.socket.send(JSON.stringify({'type':msg_type, 'auth_token':AUTH_TOKEN, 'data':data}))

    def onopen(self, event):
        self.send_message('handshake', bridge_id=self.bridge_id, initial_connection=self.initial_connection)

    def onmessage(self, event):
        print('client received msg:', event.origin, event.ports)
        if type(event.data) is 'string':
            msg = JSON.parse(event.data)
            if msg:
                if msg.type is 'connected':
                    self.initial_connection = False
                    if self.proceed:
                        self.proceed()

    def onerror(self, event):
        print('WebSocket client unhandled error:', event)

    def onclose(self, event):
        self.reconnect()

def connect_bridge(proceed):
    nonlocal bridge
    if window.self is not window.top:
        proceed()
        return  # Do not connect in child frames
    bridge = Bridge(proceed)
