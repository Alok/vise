# vim:fileencoding=utf-8
# License: GPL v3 Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>
from __python__ import hash_literals, bound_methods

from encodings import base64encode

bridge = None
AUTH_TOKEN = '__AUTH_TOKEN__'

def qt_bridge():
    return bridge

def callback(name, data, console_err):
    bridge = qt_bridge()
    if not bridge:
        console.error(console_err or ('Aborting callback: ' + name + ' as Qt bridge not available'))
    else:
        bridge.callback(name, data)

def js_to_python(name, *args):
    bridge = qt_bridge()
    if not bridge:
        console.error('Aborting js_to_python: ' + name + ' as Qt bridge not available')
    else:
        bridge.js_to_python(name, args)

def connect_signal(name, func):
    bridge = qt_bridge()
    bridge.signals[name] = func

class Bridge:

    def __init__(self, proceed):
        self.proceed = proceed
        self.signals = {}
        r = Uint8Array(16)
        window.crypto.getRandomValues(r)
        self.bridge_id = window.performance.now() + ' ' + base64encode(r)
        self.initial_connection = True
        window.get_bridge_id = def():
            return self.bridge_id
        self.reconnect()

    def reconnect(self):
        self.socket = v"new WebSocket('ws://localhost:__WEBSOCKET_PORT__')"
        self.socket.onmessage = self.onmessage
        self.socket.onclose = self.onclose
        self.socket.onopen = self.onopen
        self.socket.onerror = self.onerror

    def send_message(self, msg_type, **data):
        self.socket.send(JSON.stringify({'type':msg_type, 'auth_token':AUTH_TOKEN, 'data':data}))

    def callback(self, name, data):
        self.send_message('callback', name=name, data=data)

    def js_to_python(self, name, args):
        self.send_message('js_to_python', name=name, args=args)

    def onopen(self, event):
        self.send_message('handshake', bridge_id=self.bridge_id, initial_connection=self.initial_connection)

    def onmessage(self, event):
        if type(event.data) is 'string':
            msg = JSON.parse(event.data)
            if msg:
                mtype = msg.type
                if mtype is 'connected':
                    self.initial_connection = False
                    if self.proceed:
                        self.proceed()
                elif mtype is 'python_to_js':
                    msg = msg.data or {}
                    func = self.signals[msg.name]
                    if func:
                        args = msg.args or v'[]'
                        func(*args)
                    else:
                        print('WebSocket signal activation for unconnected signal: ' + msg.name)
                else:
                    print('WebSocket message of unknown type from python: ' + mtype)

    def onerror(self, event):
        print('WebSocket client unhandled error:', event)

    def onclose(self, event):
        self.reconnect()

def connect_bridge(proceed):
    nonlocal bridge
    if window.self is not window.top:
        proceed()
        return  # Do not connect in child frames
    bridge = Bridge(proceed)
